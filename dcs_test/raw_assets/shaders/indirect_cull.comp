#version 450

layout( constant_id = 0 ) const int MAX_LOD_LEVEL = 5;

layout( constant_id = 1 ) const int LOCAL_SIZE = 1;

layout( local_size_x_id = 1 ) in;

// Same layout as VkDrawIndexedIndirectCommand
struct Indexed_indirect_command
{
	uint index_count;
	uint instance_count;
	uint first_index;
	int base_vertex;
	uint first_instance;
};

// Binding 4: level-of-detail information
struct lod
{
	uint first_index;
	uint index_count;
	int base_vertex;
	float distance;
};

layout( set = 0, binding = 1 ) uniform raster_data
{
	mat4 view;
	mat4 proj;
	vec4 cam;
	vec4 frustum[6];
}
raster;

layout( set = 1, binding = 0 ) readonly buffer lod_data
{
	lod lods[MAX_LOD_LEVEL];
};

layout( set = 1, binding = 1 ) readonly buffer instance_data
{
	mat4 instances[];
};

// Binding 1: Multi draw output
layout( set = 1, binding = 2 ) writeonly buffer indirect_draw
{
	Indexed_indirect_command indirect[];
};


bool frustum_check( vec4 pos )
{
	// Check sphere against frustum planes
	for ( int i = 0; i < 1; i++ )
	{
		if ( dot( pos, raster.frustum[i] ) < -1 )
		{
			return false;
		}
	}
	return true;
}

void main()
{
	uint idx = gl_GlobalInvocationID.x +
		gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;

	vec4 pos = instances[idx][3];

	// Check if object is within current viewing frustum
	if ( frustum_check( pos ) )
	{
		// Select appropriate LOD level based on distance to camera
		uint lod_level = MAX_LOD_LEVEL;
		for ( uint i = 0; i < MAX_LOD_LEVEL; i++ )
		{
			if ( distance( pos.xyz, raster.cam.xyz ) < lods[i].distance )
			{
				lod_level = i;
				break;
			}
		}
		indirect[idx].index_count = lods[lod_level].index_count;
		indirect[idx].instance_count = 1;
		indirect[idx].first_index = lods[lod_level].first_index;
		indirect[idx].base_vertex = lods[lod_level].base_vertex;
		indirect[idx].first_instance = idx;
	}
	else
	{
		indirect[idx].instance_count = 0;
	}
}